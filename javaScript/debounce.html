<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=\, initial-scale=1.0">
    <title>debounce,throttle高级封装</title>
</head>
<body>
    防抖：在一定时间内只触发一次，如果在这个时间内又触发了该事件，则会重新计算函数执行事件

    节流：只在一定时间内触发一次
    <script>
        // 简单防抖，没有处理fn返回值的情况
        const simpleDebounce = (fn, ms) => {
            let timer
            return function() {
                if(timer) {
                    clearTimeout()
                }
                timer = setTimeout(() => {
                    fn()
                } , ms)
            }
        }

        // 高级防抖函数，包括立即执行和取消执行
        const debounce = (fn, ms = 1000) => {
            let timer = null
            let args
            function  main(...arg) {
                args = arg
                if (timer) {
                    cancel()
                }
                return new Promise((resolve, reject) => {
                    timer = setTimeout(async () => {
                        try {
                            resolve(await fn.apply(this, args))
                        } catch (error) {
                            reject(error)
                        }
                    }, ms)
                })
            }

            function  cancel() {
                clearTimeout(timer)
                timer = null
            }

            function flush() {
                cancel()
                return fn.apply(this, args)
            }

            main.cancel = cancel
            main.flush = flush
            return main
        }

        const test = debounce(() => {
            return 1000
        }, 500)
        const simpletest = simpleDebounce(() => {
            return 2000
        },500)
        

        function throttle(fn, ms = 1000) {
            let timer = null
            let args
            let flag = false
            
            // 这种写法 flag为true  return返回时，会造成调用的地方报错
            // function main(...arg) {
            //     if (flag) {
            //         // 在此处不能清除timer等，因为setTimeout是后触发，此时第一次执行throttle后，setTimeout的内容还未执行
            //         return
            //     }
            //     if (timer) {
            //         cancel()
            //     }

            //     flag =  true
            //     args = arg
            //     return new Promise((resolve, reject) => {
            //         timer = setTimeout(async() => {
            //             try {
            //                 resolve(await fn.apply(this, args))
            //                 cancel()
            //             } catch (error) {
            //                 reject(error)
            //                 cancel()
            //             }
            //         })
            //     })
            // }

            function main(...arg) {
                return new Promise((resolve, reject) => {
                    if (flag) {
                        return resolve(`${fn}函数${ms}s内只会执行一次`)
                    }
                    if (timer) {
                        cancel()
                    }
                    flag =  true
                    args = arg

                    timer = setTimeout(async() => {
                        try {
                            resolve(await fn.apply(this, args))
                            cancel()
                        } catch (error) {
                            reject(error)
                            cancel()
                        }
                    })
                })
            }

            function cancel() {
                clearTimeout(timer)
                timer = null
                flag = false
            }

            function flush() {
                cancel()
                return fn.apply(this, args)
            }

            main.cancel = function() {
                cancel()
                args = null
            }
            main.flush = flush

            return main
        }

        const throttling = throttle(() => {
            return 3000
        }, 500)

        console.log(throttling)

        for (let i = 0; i < 10; i++) {
            // test().then(res => {
            //     console.log(i)
            //     console.log(res)
            // })

            // const num = simpletest()
            // console.log(num)

            throttling().then(res => {
                console.log(res)
            })
        }
        
    </script>
</body>
</html>