<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>promise的原理探索</title>
</head>
<body>
    <a href="https://blog.csdn.net/sinat_17775997/article/details/83376452?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161827883016780264075834%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161827883016780264075834&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-83376452.first_rank_v2_pc_rank_v29&utm_term=Promise%E5%8E%9F%E7%90%86" target="_blank">相关链接1</a>

    promise和async/await的区别
    <a href="https://blog.csdn.net/qq_37617413/article/details/90637694?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161771947616780266230702%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161771947616780266230702&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-90637694.first_rank_v2_pc_rank_v29&utm_term=promise%E5%92%8Casync%2Fawait%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank">相关链接2</a>
    简单来说：
        async await与Promise一样，是非阻塞的
        1.promise是es6  async/await是es7
        2.写法更加优雅，其实async/await是寄生于promise
        3.promise捕获错误的方式时catch，async/await使用then或者try catch捕获

    <script>

        // executor: 执行器，执行器会立马执行
        function Promise1(executor) {
            console.log(executor)
            function resolve(val) {
                
            }

            function reject(val) {
                
            }

            try {
                executor(resolve,reject)
            } catch (e) {
                reject(e)
            }
        }

        // const promise1 = new Promise1((resolve, reject) => {
        //     console.log('简单demo')
        // })

        function Promise2(executor) {
            var self = this //resolve,reject中的this指向不是promise实例，需用self缓存
            self.state = 'padding'
            self.value = '' // 缓存成功回调的onfulfilled的参数
            // self.reson = '' // 缓存失败回调onrejected的参数
            self.onResolved = [] // 存放成功的回调onfulfilled的集合
            self.onRejected = [] // 存放失败的回调onrejected的集合

            function resolve(value) {
                if (self.state === 'padding') {
                    self.state = 'resolved'
                    self.value = value
                    self.onResolved.forEach(fn => {
                        return fn()
                    })
                }
            }

            function reject(value) {
                self.state = 'rejected'
                self.value = value
                self.onRejected.forEach(fn => fn())
            }

            try {
                executor(resolve, reject)
            } catch (e) {
                reject(e)
            }
        }

        // const promise2 = new Promise2((r, j) => {
        //     console.log(22)
        //     r(22)
        // })

        Promise2.prototype.then = function (onfulfilled, onrejected) {
            var self = this
            if (this.state === 'resolved') {
                onfulfilled(self.value)
            }

            if (this.state === 'rejected') {
                onrejected(self.value)
            }

            if (this.state === 'padding') {
                this.onResolved.push(function () {
                    onfulfilled(self.value)
                })
            }
        }

        

        
    </script>
</body>
</html>